// controllers/claimControllerDummy.js
const pool = require('../config/db.config');
const format = require('pg-format'); // We only need pg-format now

// Get all dummy claims with pagination
const getDummyClaims = async (req, res) => {
    const { page = 1, pageSize = 10, filters = [] } = req.query;
    const offset = (page - 1) * pageSize;

    const { whereClause, params } = buildWhereClause(filters);
    const whereSQL = whereClause ? `WHERE ${whereClause}` : '';

    try {
        const countQuery = `SELECT COUNT(*) FROM claims_dummy ${whereSQL}`;
        const totalCountResult = await pool.query(countQuery, params);
        const totalCount = parseInt(totalCountResult.rows[0].count);

        const dataQuery = `
            SELECT * FROM claims_dummy
            ${whereSQL}
            ORDER BY claim_merged_id ASC
            LIMIT $${params.length + 1} OFFSET $${params.length + 2}
        `;
        const dataParams = [...params, pageSize, offset];
        const dataResult = await pool.query(dataQuery, dataParams);

        res.json({
            data: dataResult.rows,
            metadata: {
                totalCount,
                totalPages: Math.ceil(totalCount / pageSize),
                currentPage: page,
                pageSize,
            },
        });
    } catch (error) {
        console.error('Error fetching claims with filters:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
};


// Get a single dummy claim by ID
const getDummyClaimById = async (req, res) => {
    const { id } = req.params;
    try {
        const result = await pool.query(
            'SELECT * FROM claims_dummy WHERE claim_merged_id = $1',
            [id]
        );
        if (result.rows.length === 0) {
            return res.status(404).json({ error: 'Claim not found' });
        }
        res.json(result.rows[0]);
    } catch (err) {
        console.error(`Error fetching claim with ID ${id}:`, err);
        res.status(500).json({ error: 'Internal server error' });
    }
};

const buildWhereClause = (filters) => {
    let conditions = [];
    let params = [];
    filters.forEach((filter, index) => {
        const paramIndex = index + 1; // SQL parameter index starts at 1
        const { column, operator, value, secondValue } = filter;

        switch (operator) {
            case 'equals': conditions.push(`${column} = $${paramIndex}`); params.push(value); break;
            case 'notEquals': conditions.push(`${column} != $${paramIndex}`); params.push(value); break;
            case 'greaterThan': conditions.push(`${column} > $${paramIndex}`); params.push(value); break;
            case 'lessThan': conditions.push(`${column} < $${paramIndex}`); params.push(value); break;
            case 'between':
                conditions.push(`${column} BETWEEN $${paramIndex} AND $${paramIndex + 1}`);
                params.push(value, secondValue);
                break;
            case 'contains': conditions.push(`${column} ILIKE '%' || $${paramIndex} || '%'`); params.push(value); break;
            case 'isNull': conditions.push(`${column} IS NULL`); break;
            case 'isNotNull': conditions.push(`${column} IS NOT NULL`); break;
            default: break;
        }
    });
    return { whereClause: conditions.join(' AND '), params };
};


// Create a new dummy claim
const createDummyClaim = async (req, res) => {
    const {
        claim_id,
        patient_id,
        date_of_birth,
        gender,
        provider_id,
        facility_id,
        diagnosis_code,
        procedure_code,
        admission_date,
        discharge_date,
        revenue_code,
        modifiers,
        claim_type,
        total_charges,
        allowed_amount
    } = req.body;

    try {
        // claim_merged_id will be automatically generated by SERIAL
        const query = `
            INSERT INTO claims_dummy (
                claim_id,
                patient_id,
                date_of_birth,
                gender,
                provider_id,
                facility_id,
                diagnosis_code,
                procedure_code,
                admission_date,
                discharge_date,
                revenue_code,
                modifiers,
                claim_type,
                total_charges,
                allowed_amount
            ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)
            RETURNING *;
        `;
        
        const values = [
            claim_id,
            patient_id,
            date_of_birth,
            gender,
            provider_id,
            facility_id,
            diagnosis_code,
            procedure_code,
            admission_date,
            discharge_date,
            revenue_code,
            modifiers,
            claim_type,
            total_charges,
            allowed_amount
        ];

        const result = await pool.query(query, values);
        res.status(201).json(result.rows[0]);
    } catch (err) {
        console.error('Error creating dummy claim:', err);
        res.status(500).json({ error: 'Internal server error' });
    }
};

// Update an existing dummy claim
const updateDummyClaim = async (req, res) => {
    const { id } = req.params;
    const {
        patient_id,
        date_of_birth,
        gender,
        provider_id,
        facility_id,
        diagnosis_code,
        procedure_code,
        admission_date,
        discharge_date,
        revenue_code,
        modifiers,
        claim_type,
        total_charges,
        allowed_amount
    } = req.body;

    try {
        const query = `
            UPDATE claims_dummy
            SET
                patient_id = $1,
                date_of_birth = $2,
                gender = $3,
                provider_id = $4,
                facility_id = $5,
                diagnosis_code = $6,
                procedure_code = $7,
                admission_date = $8,
                discharge_date = $9,
                revenue_code = $10,
                modifiers = $11,
                claim_type = $12,
                total_charges = $13,
                allowed_amount = $14
            WHERE claim_merged_id = $15
            RETURNING *;
        `;
        
        const values = [
            patient_id,
            date_of_birth,
            gender,
            provider_id,
            facility_id,
            diagnosis_code,
            procedure_code,
            admission_date,
            discharge_date,
            revenue_code,
            modifiers,
            claim_type,
            total_charges,
            allowed_amount,
            id
        ];

        const result = await pool.query(query, values);
        if (result.rows.length === 0) {
            return res.status(404).json({ error: 'Claim not found' });
        }
        res.json(result.rows[0]);
    } catch (err) {
        console.error(`Error updating claim with ID ${id}:`, err);
        res.status(500).json({ error: 'Internal server error' });
    }
};

// Delete a dummy claim
const deleteDummyClaim = async (req, res) => {
    const { id } = req.params;
    try {
        const result = await pool.query(
            'DELETE FROM claims_dummy WHERE claim_merged_id = $1 RETURNING *',
            [id]
        );
        if (result.rows.length === 0) {
            return res.status(404).json({ error: 'Claim not found' });
        }
        res.json({ message: 'Claim deleted successfully' });
    } catch (err) {
        console.error(`Error deleting claim with ID ${id}:`, err);
        res.status(500).json({ error: 'Internal server error' });
    }
};

const createBatchClaims = async (req, res) => {
  const client = await pool.connect();
  try {
    await client.query('BEGIN');
    
    const { claims, ingestionId } = req.body;
    
    console.log(`Processing ${claims.length} claims for ingestion ${ingestionId}`);
    const batchStartTime = Date.now();

    // Check for existing claim_id/line_id combinations
    const existingClaimsResult = await client.query(
      'SELECT claim_id, line_id FROM claims_dummy WHERE claim_id = ANY($1)',
      [claims.map(c => c.claim_id)]
    );
    const existingCombos = new Set(
      existingClaimsResult.rows.map(row => `${row.claim_id}_${row.line_id}`)
    );

    // Filter out duplicates and prepare values for insertion
    const duplicates = [];
    const validClaims = claims.filter((claim, index) => {
      const combo = `${claim.claim_id}_${claim.line_id || `line_${index + 1}`}`;
      if (existingCombos.has(combo)) {
        duplicates.push({
          claim_id: claim.claim_id,
          line_id: claim.line_id || `line_${index + 1}`,
          reason: 'Duplicate claim_id and line_id combination'
        });
        return false;
      }
      return true;
    });

    if (validClaims.length === 0) {
      return res.status(400).json({
        error: 'No valid claims to insert',
        duplicates
      });
    }

    // Prepare values for bulk insert
    const values = validClaims.map((claim, index) => [
      claim.claim_id,
      claim.line_id || `line_${index + 1}`,
      claim.patient_id,
      claim.date_of_birth,
      claim.gender,
      claim.provider_id,
      claim.facility_id,
      claim.diagnosis_code,
      claim.procedure_code,
      claim.admission_date,
      claim.discharge_date,
      claim.revenue_code,
      claim.modifiers?.replace('\r', ''),
      claim.claim_type,
      parseFloat(claim.total_charges) || 0,
      parseFloat(claim.allowed_amount?.replace('\r', '')) || 0,
      ingestionId
    ]);

    const insertQuery = format(
      `INSERT INTO claims_dummy (
        claim_id, line_id, patient_id, date_of_birth, gender, provider_id,
        facility_id, diagnosis_code, procedure_code, admission_date,
        discharge_date, revenue_code, modifiers, claim_type,
        total_charges, allowed_amount, ingestion_id
      ) VALUES %L RETURNING claim_id, line_id`,
      values
    );

    const result = await client.query(insertQuery);
    await client.query('COMMIT');
    
    console.log(`Batch completed: ${result.rows.length} claims inserted, ${duplicates.length} duplicates skipped`);

    res.json({ 
      successCount: result.rows.length,
      duplicateCount: duplicates.length,
      duplicates,
      claimIds: result.rows.map(row => ({
        claim_id: row.claim_id,
        line_id: row.line_id
      }))
    });

  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Batch insert error:', error);
    res.status(500).json({ 
      error: 'Failed to insert claims batch',
      details: error.message
    });
  } finally {
    client.release();
  }
};

module.exports = {
    getDummyClaims,
    getDummyClaimById,
    createDummyClaim,
    updateDummyClaim,
    deleteDummyClaim,
    createBatchClaims
};